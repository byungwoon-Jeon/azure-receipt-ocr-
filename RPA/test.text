import re
from typing import Optional

def extract_delivery_address_from_content(content: str) -> Optional[str]:
    """
    content 안에 '배달주소'라는 라벨이 있을 때만 그 뒤에서 주소 문자열을 추출.
    - '배달주소' 뒤의 구분자(:, -, 공백) 허용
    - 줄바꿈 또는 다른 라벨(전화/사업자/주문/결제 등)이 나오기 전까지만 캡처
    - 과도한 전역 주소 탐지는 하지 않음(가게 주소 오탐 방지)
    - 없으면 None 반환
    """
    if not content:
        return None

    text = content

    # '배달주소' 라벨 뒤 최대 120자만 창(window)으로 보고, 줄바꿈/다른 라벨 직전까지 캡처
    # 필요시 stop 토큰(전화/사업자/주문/결제/주소/가게 등)을 추가/수정 가능
    pattern = re.compile(
        r"(배달\s*주소)\s*[:：\-]?\s*(?P<addr>.{0,120})",
        flags=re.IGNORECASE
    )

    stop_tokens = re.compile(
        r"(?:\r?\n|전화|연락처|휴대폰|사업자|주문|결제|영수증|가게|상호|주소\s*:|배송\s*지|수령\s*지)"
    )

    for m in pattern.finditer(text):
        window = m.group("addr")
        # 줄바꿈/스톱 토큰 전까지 자르기
        stop = stop_tokens.search(window)
        if stop:
            window = window[:stop.start()]

        # 앞뒤 공백/구두점 정리
        addr = window.strip(" \t,;:.-|•·\u200b").strip()
        # 중복 공백 축소
        addr = re.sub(r"\s{2,}", " ", addr)

        # 너무 짧으면 스킵(예: 빈 문자열/의미 없음)
        if len(addr) >= 5:
            return addr

    return None

import re
from typing import Optional

def extract_business_no(content: str) -> Optional[str]:
    """
    영수증 전체 텍스트(content)에서 사업자번호를 추출해 정규화하여 반환.
    - 우선 '사업자(등록)번호' 라벨 인접 영역에서 탐색
    - 폴백으로 문서 전체에서 9~10자리 숫자 패턴(3-2-4/5) 탐색
    - 전화번호(01x-xxx-xxxx / 01x-xxxx-xxxx) 등은 제외
    - 반환: 10자리 -> 000-00-00000, 9자리 -> 000-00-0000, 없으면 None
    """
    if not content:
        return None

    text = content

    # 1) 라벨 근처 우선 탐색: '사업자번호', '사업자 등록번호', '사업자등록번호' 등
    #    라벨 뒤 0~40자 내에서 숫자/하이픈/공백으로 이뤄진 덩어리 캡처
    label_pattern = re.compile(
        r'(사업자\s*등록?\s*번호)\s*[:：]?\s*([0-9\-\s]{7,20})',
        flags=re.IGNORECASE
    )
    m = label_pattern.search(text)
    candidates = []
    if m:
        candidates.append(m.group(2))

    # 2) 폴백: 문서 전체에서 3-2-(4|5) 패턴 탐색(하이픈/공백은 옵션)
    #    예: 000-00-00000 / 000 00 00000 / 0000000000
    generic_pattern = re.compile(
        r'\b(\d{3}[-\s]?\d{2}[-\s]?\d{4,5})\b'
    )
    for m in generic_pattern.finditer(text):
        candidates.append(m.group(1))

    # 3) 후보 정제: 전화번호/날짜 등 오탐 제거 후 숫자만 남겨 길이 체크
    #    - 전화번호(01x 시작 10~11자리)는 제외
    phone_like = re.compile(r'^01[016789]\d{7,8}$')  # 010xxxxxxxx, 011xxxxxxxx 등

    def normalize_digits(s: str) -> Optional[str]:
        digits = re.sub(r'\D+', '', s)
        if not digits:
            return None
        # 전화번호 제외
        if phone_like.match(digits):
            return None
        # 9 or 10자리만 허용
        if len(digits) == 10:
            return f"{digits[0:3]}-{digits[3:5]}-{digits[5:10]}"
        elif len(digits) == 9:
            return f"{digits[0:3]}-{digits[3:5]}-{digits[5:9]}"
        else:
            return None

    # 4) 우선순위: 라벨근처 후보들 -> 폴백 후보들
    for raw in candidates:
        normalized = normalize_digits(raw)
        if normalized:
            return normalized

    return None

