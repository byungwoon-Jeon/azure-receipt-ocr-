[인수인계 문서] 승인번호 추출 로직 상세 설명

목적 (What & Why)
승인번호 추출 함수는 OCR로 얻은 영수증 CONTENTS 원문에서 결제 승인번호만 찾아내기 위해 만들어진 기능입니다. OCR 결과는 줄바꿈이 많고, APPPROVAL, AUTHORIZATION, CREDIT 같은 단어가 섞여 있어 값과 비슷한 문자열이 많습니다. 이를 방지하고 실제 승인번호만 잡아내기 위한 규칙들이 적용되어 있습니다.

주요 함수
2-1. _normalize_and_validate(token)
입력된 문자열을 승인번호 후보로 보고 정규화 및 검증을 수행합니다.
정규화:

공백 제거

대문자로 변환

유효성 검증:

길이 6~12자

영문/숫자 조합만 허용

숫자가 최소 5개 이상 포함되어야 함 (APPROVAL 같은 순수 영문 오탐 제거 목적)

이 과정을 통과한 문자열만 승인번호 후보로 인정합니다.

2-2. extract_approval_no(contents)
OCR 원문(contents)을 줄 단위로 분석하여 승인번호 라벨 뒤에 있는 값을 추출합니다.
전체 흐름은 다음과 같습니다:

CONTENTS를 줄 단위로 split 수행

각 줄에서 승인번호 라벨(LABEL_PATTERN)이 존재하는지 확인

예: "승인번호", "승인 NO", "승인 코드", "Auth", "Authorization", "Approval No", "Approval Code" 등

라벨이 발견되면 해당 라벨 "이후" 문자열(tail)에서 숫자/문자 조합 후보를 탐색

같은 줄에서 값이 없으면 바로 다음 줄에서도 값을 탐색

탐색된 후보 문자열을 normalize_and_validate에 넣어 유효성을 재검증

조건을 모두 만족하는 최초의 승인번호만 반환

끝까지 없으면 None 반환

설계 핵심 아이디어

라벨 이후 텍스트만 검사
라벨 자체가 값으로 잘못 추출되는 문제를 막기 위한 설계입니다.

공백 포함 숫자 패턴 허용
예: "1234 5678"처럼 OCR에서 중간에 공백이 생기는 경우가 많아 이를 VALUE_CHUNK 정규식에서 허용합니다. 실제 반환 시 normalize 과정에서 공백 제거됩니다.

다음 줄 검사
승인번호 라벨과 값이 다른 줄에 있는 경우가 많아 라벨 발견 시 다음 줄도 스캔합니다.

이중 검증
정규식으로 1차 필터링 후 normalize_and_validate에서 다시 길이, 숫자 비중을 확인합니다.

첫 번째 유효한 값만 반환
중복 후보가 있어도 첫 번째로 발견된 후보만 반환해 일관성을 유지합니다.

정규식 설명
LABEL_PATTERN
승인번호 의미를 가진 여러 표현을 모두 포함합니다.
예시:

"승인번호", "승인 NO", "승인코드"

"Auth", "Authorization", "Authorization Code"

"Approval No", "Approval Number", "Approval Code"

VALUE_CHUNK
영문+숫자+공백 구성의 문자열을 길이 조건에 맞춰 추출합니다.
예: A1234567, 1234 5678, 00493315 등.

normalize_and_validate에서 최종 검증을 수행하기 때문에 VALUE_CHUNK는 좀 더 범용적으로 설계되어 있습니다.

예시 동작

“승인번호 12345678” → 12345678

“승인번호\n1234 5678” → 12345678

“Auth No: A9876543” → A9876543

“Authorization code:\n213511” → 213511

“REF:31315245380 AUTH:00493315” → 00493315

“승인번호 APPROVAL NUMBER” → None
(숫자가 충분하지 않아 오탐 방지 규칙에서 걸러짐)

미탐·오탐 케이스
라벨이 없고 숫자만 있는 경우는 오탐을 막기 위해 추출하지 않습니다.
값이 라벨에서 2줄 이상 떨어져 있는 경우도 미탐될 가능성이 있습니다.

튜닝 포인트

최소 길이(6~12) 조정 가능

숫자 최소 개수 5 → 필요 시 6 이상으로 강화 가능

다음 줄 검사 범위 1줄 → 2줄 이상으로 확장 가능

라벨 사전 확장 가능 (현장 케이스 추가 시 반영)

성능
시간 복잡도는 O(라인 수)이며 매우 가볍고 안정적인 편입니다.

유지보수 팁
오탐/미탐 사례가 발견되면 다음 항목을 점검하면 됩니다:

라벨 패턴에 없어서 안 잡힌 케이스인지

VALUE_CHUNK가 후보를 잡지 못했는지

normalize_and_validate에서 길이나 숫자 비중 조건에서 걸린 것인지



[ SAP HANA vs Oracle – DBeaver 드라이버 설정 인수인계 문서 (TXT 버전) ]

개요
SAP HANA DB와 Oracle DB는 모두 DBeaver에서 JDBC 기반으로 연결 가능하나,
드라이버 구성, 접속 정보, SSL 처리 방식에서 차이가 있다.
본 문서는 신규 담당자가 SAP HANA 및 Oracle 연결을 빠르게 설정하도록 비교 정리한 것이다.

드라이버 설치 차이점 요약

SAP HANA

DBeaver 기본 제공 드라이버 사용

ngdbc.jar 다운로드 후 바로 연결 가능

외부 패키지 필요 없음

Oracle

Instant Client 설치 필요할 수 있음

ojdbc8.jar 또는 ojdbc11.jar 필요

Service/SID, TNS 등 설정 요소가 많음

SAP HANA DBeaver 연결 설정

3.1 드라이버 설정

DBeaver 실행 → Database → New Database Connection

검색창에서 "HANA" 또는 "SAP HANA" 선택

드라이버 자동 다운로드(ngdbc.jar).
내부망에서는 자동 다운로드 실패할 수 있으므로 수동으로 ngdbc.jar 추가.

3.2 연결 정보

Host: HANA 서버 IP

Port: 30015 (기본)

Username: 계정명

Password: 비밀번호

Database: 필요한 경우만 입력

3.3 드라이버 속성(Driver Properties)
내부망에서 SSL 문제가 발생할 경우 아래 옵션을 false로 설정한다.

encrypt=false

validateCertificate=false

sslValidateCertificate=false

3.4 연결 테스트
Test Connection → 성공 시 Finish
실패 시 Host/Port, 방화벽, 인증서 문제 점검

Oracle DBeaver 연결 설정

4.1 드라이버 설치

Oracle Instant Client 설치 필요(기업망 필수인 경우 많음)

DBeaver에서 ojdbc 드라이버 다운로드

환경변수가 필요한 경우: ORACLE_HOME, PATH 등록

4.2 연결 정보 입력

Host: Oracle 서버 IP

Port: 1521

Service Name 또는 SID 입력 필수

User / Password 입력

4.3 TNS 설정(필요 시)
tnsnames.ora 파일을 DBeaver에서 직접 지정 가능.
예:
ORCL =
(DESCRIPTION =
(ADDRESS = (PROTOCOL = TCP)(HOST = 10.xxx.xxx.xxx)(PORT = 1521))
(CONNECT_DATA =
(SERVER = DEDICATED)
(SERVICE_NAME = ORCL)
)
)

HANA vs Oracle 설정 절차 비교

단순성

HANA는 Host/Port/User/Password만으로 즉시 연결 가능

Oracle은 Instant Client, Service/SID, TNS 등 구성 요소가 많음

내부망 이슈

HANA는 validateCertificate=false 로 대부분 해결

Oracle은 wallet 또는 thick mode 설정 필요할 수 있음

포트

HANA: 30015

Oracle: 1521




[ YOLO 최신버전 재학습(Re-training) 인수인계 문서 (TXT 버전) ]

개요
YOLO 모델(v8~v11)은 Ultralytics 라이브러리를 사용하여 손쉽게 재학습이 가능하다.
본 문서는 사내 OCR/영수증 프로젝트에서 사용하는 YOLO 모델을 최신버전으로 재학습하기 위한 최소 절차를 정리한 것이다.
데이터 준비 → YAML 구성 → Training 실행 → 결과 확인 순으로 진행한다.

사전 준비

2.1 설치
pip install ultralytics
또는 회사 내부망 환경에서는 오프라인 wheel 파일로 설치한다.

2.2 모델 버전

최신 YOLO: YOLOv10 또는 YOLOv11

재학습 시 base 모델 선택: yolov8n.pt / yolov8s.pt / yolov8m.pt 등
(영수증 영역 검출은 보통 n 또는 s로 충분)

데이터셋 구성

3.1 기본 구조
YOLO는 아래 구조를 따라야 한다.

dataset/
├── images/
│ ├── train/
│ └── val/
└── labels/
├── train/
└── val/

3.2 라벨 포맷

YOLO txt 포맷

각 줄: class x_center y_center width height

모든 좌표는 0~1 사이 비율값

3.3 클래스 설정
예:
class 0 = receipt

데이터 설정 파일(data.yaml) 작성

예시:

train: /path/to/dataset/images/train
val: /path/to/dataset/images/val

nc: 1
names: ["receipt"]

경로는 절대경로 또는 상대경로 모두 가능하나 내부 서버에서는 절대경로 권장.

재학습 실행

터미널/파이썬에서 명령어 실행:

yolo detect train model=yolov8s.pt data=data.yaml epochs=50 imgsz=640 batch=16

주요 옵션

model: 시작할 base 모델

data: data.yaml 경로

epochs: 학습 반복 수(기본 50~100)

imgsz: 입력 이미지 크기(기본 640)

batch: GPU 용량 따라 조절

내부망 GPU 서버에서는 batch 16~32 권장.
메모리 부족 시 CUDA out of memory 발생 → batch 축소.

학습 결과 확인

학습 완료 후 runs/detect/train/ 디렉토리 생성:

runs/detect/train/
├── weights/
│ ├── best.pt
│ └── last.pt
├── results.png (학습 정확도 그래프)
└── confusion_matrix.png

배포용 모델: best.pt

모델 적용

기존 코드에서 YOLO 모델 로드 부분을 아래처럼 변경:

from ultralytics import YOLO
model = YOLO("best.pt")

이후 기존 inference 코드 그대로 수행.

검증(Validation)

명령어:

yolo detect val model=best.pt data=data.yaml

필요 시 추가 지표 확인 가능:

mAP50, mAP50-95

precision, recall




[ LabelImg 사용법 인수인계 문서 (TXT 버전) ]

개요
LabelImg는 가장 가벼운 오픈소스 라벨링 툴로, YOLO 포맷의 bounding box 라벨링을 간단하게 수행할 수 있다.
영수증 영역 검출 모델 학습 시 필수 도구이며, Python 기반이라 내부망 환경에서도 쉽게 사용 가능하다.

설치

방법 1) pip 설치
pip install labelImg

방법 2) GitHub 소스 설치

git clone https://github.com/heartexlabs/labelImg

pip install pyqt5 lxml

python labelImg.py 실행

※ 회사 내부망에서 pip이 안 될 경우 wheel 파일 설치 또는 zip 다운로드 후 실행 가능.

실행

방법 1) 명령어
labelImg

방법 2) 소스 실행
python labelImg.py

실행 후 기본 UI가 뜨며 이미지 불러오기(Open Dir) 메뉴를 사용할 수 있다.

YOLO 포맷 설정

LabelImg는 기본적으로 Pascal VOC(XML) 포맷이 기본값이므로 YOLO 포맷으로 변경해야 한다.

메뉴 →
View → YOLO Format
또는
Right Panel 상단 → "PascalVOC" 버튼을 클릭하여 "YOLO"로 변경

변경 후 저장되는 라벨 파일은 .txt 형식이 된다.

라벨링 작업 절차

5.1 이미지 폴더 열기

Open Dir 클릭

라벨링할 이미지들이 들어있는 디렉토리 선택

이미지 하나씩 표시됨

5.2 클래스 설정
메뉴 상단 "Edit → Create Rectangle" 또는 'W' 키 눌러 박스 생성
최초 박스 생성 시 클래스 이름 입력
예: receipt

클래스 추가 시:
右쪽 패널 "Create/Edit Label" 영역에서 추가 가능

5.3 바운딩 박스 생성
마우스로 드래그하여 박스 생성
정확도를 위해 모서리 조절 가능

5.4 단축키

W: 박스 그리기

D: 다음 이미지

A: 이전 이미지

Ctrl + S: 저장

Delete: 선택 박스 삭제

YOLO 라벨 파일 저장 구조

LabelImg가 YOLO 포맷(.txt)으로 저장하는 구조:

예시:
0 0.512 0.480 0.920 0.850

각각 의미:
class_id x_center y_center width height
(모두 이미지 대비 0~1 비율값)

라벨 파일명은 이미지와 1:1 대응:
image001.jpg
image001.txt

데이터셋 구조 구성(학습용)

YOLO 학습 시 아래 구조를 유지해야 한다.

dataset/
├── images/
│ ├── train/
│ └── val/
└── labels/
├── train/
└── val/

라벨링이 끝난 txt 파일을 images와 동일한 구조로 labels 폴더에 배치하면 된다.

품질 체크(검수)

bounding box가 이미지 바깥으로 나가지 않았는지

클래스명 오타가 없는지

receipt 영역이 정확히 전체 영수증을 포함하는지

중복 라벨이 없는지

학습 품질에 직접 영향을 주므로 샘플 검수 후 학습 진행 권장.

트러블슈팅

문제: YOLO 포맷이 저장되지 않음
→ View 메뉴에서 YOLO Format이 선택되어 있는지 확인

문제: 라벨이 계속 PascalVOC(XML)로 저장됨
→ 오른쪽 패널 포맷 버튼이 VOC로 남아있는 상태 → YOLO로 반드시 전환

문제: 이미지 불러올 때 한글 경로에서 오류
→ Windows 환경에서는 이미지 폴더 이름을 영문으로 변경 권장

문제: txt가 생성되었는데 클래스가 안 보임
→ 첫 라벨링 시 클래스 이름을 잘못 저장했을 가능성이 있음 → classes.txt 삭제 후 재입력

인수인계 핵심 요약

pip install labelImg 후 labelImg 실행

View → YOLO Format 선택

이미지 폴더 Open Dir

W 키로 박스 생성, 클래스 입력(receipt)

이미지와 동일 이름으로 .txt 생성됨

YOLO 학습 구조(images/train, labels/train)에 맞게 파일 구성

best.pt를 만들기 위해서는 라벨 품질이 중요함