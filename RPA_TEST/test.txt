import re
import logging
from typing import Optional

LOGGER = logging.getLogger("APPROVAL_EXTRACT")

# 라벨 패턴: 한국어/영어 변형을 폭넓게 커버하되 'Approval Number' 같은 조합 포함
LABEL_PATTERN = re.compile(
    r"(?:"
    r"승인\s*(?:번호|NO|코드)"
    r"|"
    r"Auth(?:orization|entication)?(?:\s*(?:No|Code))?"
    r"|"
    r"Approval\s*(?:No|Number|Code)"
    r")",
    re.IGNORECASE,
)

# 값 후보 토큰: 숫자와 공백/대문자 조합.  (최종 검증은 별도 함수에서)
VALUE_CHUNK = re.compile(r"[A-Z0-9][A-Z0-9\s]{5,20}", re.IGNORECASE)

def _normalize_and_validate(token: str) -> Optional[str]:
    """
    공백 제거/대문자화 후 승인번호 유효성 검사:
    - 길이: 6~12
    - 영문/숫자만
    - 숫자 개수 >= 5  (순수 영문 방지)
    """
    if not token:
        return None
    norm = token.replace(" ", "").upper()

    if not (6 <= len(norm) <= 12):
        return None
    if not re.fullmatch(r"[A-Z0-9]+", norm):
        return None

    digit_count = sum(c.isdigit() for c in norm)
    if digit_count < 5:
        return None  # 'APPROVAL' 같은 순수/과다영문 방지

    return norm

def extract_approval_no(contents: str) -> Optional[str]:
    """
    영수증 CONTENTS에서 승인번호를 추출.
    - 라벨(승인번호/승인 NO/승인코드/Auth/Authorization/Approval (No|Number|Code) 등) 필수
    - 라벨 직후(같은 줄)에서 값 탐색 → 없으면 다음 줄 탐색
    - 값은 공백 포함 가능 (예: '1234 5678'), 검증 시 공백 제거
    - 여러 개면 첫 번째만 반환
    """
    if not contents or not isinstance(contents, str):
        return None

    lines = contents.splitlines()
    for i, line in enumerate(lines):
        m = LABEL_PATTERN.search(line)
        if not m:
            continue

        # 1) 같은 줄: 라벨 "이후" 부분만 값 탐색 (라벨 단어가 값으로 오탐되는 것 방지)
        tail = line[m.end():]
        m_val = VALUE_CHUNK.search(tail)
        if m_val:
            candidate = _normalize_and_validate(m_val.group())
            if candidate:
                return candidate

        # 2) 다음 줄에서 값 탐색
        if i + 1 < len(lines):
            m_next = VALUE_CHUNK.search(lines[i + 1])
            if m_next:
                candidate = _normalize_and_validate(m_next.group())
                if candidate:
                    return candidate

    return None