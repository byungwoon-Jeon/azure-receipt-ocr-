# pre_pre_process.py 상단 근처에 추가/보강
import io, time, os
from PIL import Image, ImageFile, UnidentifiedImageError
from PIL import Image as PILImage
from PIL import ImageChops

# 손상 파일도 강제 로드 허용, 초대형 이미지 허용치 상향(환경에 맞게 조정)
ImageFile.LOAD_TRUNCATED_IMAGES = True
Image.MAX_IMAGE_PIXELS = 100_000_000

def convert_to_png(input_path: str, save_dir: str) -> str:
    logger.info("[시작] convert_to_png")
    t0 = time.time()
    try:
        assert os.path.isfile(input_path), f"파일이 존재하지 않음: {input_path}"
        os.makedirs(save_dir, exist_ok=True)

        filename = os.path.splitext(os.path.basename(input_path))[0] + ".png"
        save_path = os.path.join(save_dir, filename)

        # 1) 원본 바이트를 한 번에 읽어 BytesIO로 넘김(네트워크/락 이슈 회피)
        #    → OS 파일 핸들은 즉시 닫히므로 AV/락에 덜 걸림
        with open(input_path, "rb") as f:
            raw = f.read()

        # 2) 1차: verify()로 파일 무결성 검사 (디코더 빨리 터뜨리고 원인 로그 확보)
        bio = io.BytesIO(raw)
        try:
            img_probe = Image.open(bio)
            img_probe.verify()  # 디코더/헤더 검증만 수행
        except UnidentifiedImageError as ue:
            logger.error(f"[ERROR] Pillow가 포맷을 식별 못함: {ue}")
            raise
        except Exception as e:
            logger.error(f"[ERROR] 이미지 검증 실패(손상/미지원 코덱 가능성): {e}")
            raise
        finally:
            # verify() 호출 후엔 재사용하지 않음
            del img_probe

        # 3) 2차: 실제 로딩 (새 BytesIO로 재오픈) + 강제 load()로 지연평가 제거
        bio2 = io.BytesIO(raw)
        with Image.open(bio2) as img:
            _ = img.size        # 메타 접근
            img.load()          # 여기서 멈추면 디코더/코덱 문제 가능성 매우 높음
            out = img.convert("RGB")
            out.save(save_path, "PNG", optimize=True)

        dt = time.time() - t0
        logger.info(f"[종료] convert_to_png → {save_path} ({dt:.2f}s)")
        return save_path

    except Exception as e:
        logger.error(f"[ERROR] convert_to_png 실패: {e}", exc_info=True)
        raise